# Architecture

> Auto-generated by /map on 2026-02-26

## Overview

AgriChain is a client-server Farm-to-Market Intelligence Platform. A Flutter mobile application serves as the frontend client, consumed by the farmers. The backend is a stateless Go REST API handling heavy predictive modeling, weather routing, and dynamic data generation for recommendations to minimize crop loss.

```
┌─────────────────────────────────────────┐
│        [Flutter Mobile Client]          │
│  (api_service.dart, geolocator mapping) │
├─────────────────────────────────────────┤
│          [Go REST API (Gin)]            │
│  (main.go: Routing, ML logic, JSON)     │
├─────────────────────────────────────────┤
│            [External APIs]              │
│  (Open-Meteo, data.gov.in Mandi APIs)   │
└─────────────────────────────────────────┘
```

## Components

### Flutter Mobile Client (`frontend/`)
- **Purpose:** Cross-platform mobile front-end displaying localized context, weather data, preservation ranked actions, and map boundaries.
- **Location:** `frontend/lib/`
- **Dependencies:** `http`, `geolocator`, `flutter_map`, `shared_preferences`.

### Go Backend REST API (`backend/`)
- **Purpose:** Central processing engine exposing endpoints like `/api/v1/recommendation` and `/api/v1/health`. Contains predictive regressions (`simulateHistoricalData`, `forecastPriceTrend`), deterministic soil calculations (`fetchSoilHealth`), and dynamic preservation action generation.
- **Location:** `backend/main.go`, `backend/models.go`
- **Dependencies:** `github.com/gin-gonic/gin` (Routing), `database/sql` (via squirrel/sqlx though DB usage is minimal MVP right now).

## Data Flow

1. The Farmer opens the Flutter app. `Geolocator` fetches current coordinates (or reads from manual pin drop on `flutter_map`).
2. Flutter Client calls `GET /api/v1/recommendation` on the Go backend with `farmer_id`, `crop_id`, `lat`, and `lon`.
3. Go Backend performs simultaneous external routines:
   a. Geohashes lat/lon for stable NPK base stats.
   b. Calls `Open-Meteo API` for live weather/soil moisture data.
   c. Processes simulated/live `data.gov.in` Mandi prices and scores them based on OSRM transit time estimates and price trends.
4. Backend dynamically builds response including localized `why` strings and outputs JSON to client.
5. Flutter Client parses `Recommendation` and renders it via intuitive badge UIs and categorized cards.

## Integration Points

| Service | Type | Purpose |
|---------|------|---------|
| Open-Meteo | API | Real-time weather and sub-surface soil moisture stats |
| data.gov.in | API | Live Mandi (Agricultural Market) pricing across India |

## Technical Debt

- [ ] Go Backend currently uses mocked local simulations for Mandi data instead of live DB reads for Phase 1.
- [ ] No PostgreSQL connection string is strictly enforced in the current main endpoint though imports exist.
- [ ] Missing global App Error Boundary UI inside the Flutter Client (relies heavily on basic Try/Catch localized strings).

## Conventions

**Naming:** `snake_case` for raw Go JSON payloads, `camelCase` for Go/Dart internally parsed properties.
**Structure:** Monolith folder separation `frontend/` vs `backend/`.
**Testing:** Flutter standard `flutter_test`, Backend unit tests missing.
